/**
 * API 测试接口备份
 *
 * 这些是开发/调试用的测试 API，已从主 index.ts 文件中移出
 *
 * 包含的测试接口：
 * - /api/test-blob - 测试 Vercel Blob 配置
 * - /api/test-db - 测试数据库连接
 * - /api/test-siliconflow-full - 测试硅基流动图片生成（通过函数）
 * - /api/test-siliconflow - 测试硅基流动图片生成 API
 * - /api/test-imagen - 测试 Google Imagen 图片生成 API
 * - /api/test-jimeng - 测试即梦图片生成 API
 * - /api/test-ai - 测试 AI 连接
 *
 * 创建时间: 2026-01-31
 */

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { sql } from '@vercel/postgres';
import { put } from '@vercel/blob';
import { getAIClient } from './index';

// ==================== 测试 Vercel Blob 配置 ====================
export async function testBlob(req: VercelRequest, res: VercelResponse) {
  const blobToken = process.env.BLOB_READ_WRITE_TOKEN;

  const envCheck = {
    BLOB_READ_WRITE_TOKEN: blobToken ? `${blobToken.substring(0, 20)}...` : '未设置',
  };

  if (!blobToken) {
    return res.status(200).json({
      success: false,
      message: 'Vercel Blob Token 未配置',
      envCheck,
      guide: '请在 Vercel 控制台创建 Blob Store，环境变量 BLOB_READ_WRITE_TOKEN 会自动添加',
    });
  }

  try {
    // 测试上传一个小文件
    const testContent = `Test file created at ${new Date().toISOString()}`;
    const blob = await put(`test/test-${Date.now()}.txt`, testContent, {
      access: 'public',
      contentType: 'text/plain',
    });

    return res.status(200).json({
      success: true,
      message: 'Vercel Blob 配置正确！',
      envCheck,
      testFile: {
        url: blob.url,
        pathname: blob.pathname,
      },
    });
  } catch (error: any) {
    return res.status(200).json({
      success: false,
      message: 'Vercel Blob 上传测试失败',
      envCheck,
      error: error.message,
    });
  }
}

// ==================== 测试数据库连接 ====================
export async function testDb(req: VercelRequest, res: VercelResponse) {
  const result = await sql`SELECT NOW() as current_time`;
  return res.status(200).json({
    success: true,
    message: 'Database connected!',
    data: {
      currentTime: result.rows[0].current_time,
    },
  });
}

// ==================== 测试硅基流动图片生成 API（通过正式的 generateImage 函数）====================
export async function testSiliconflowFull(req: VercelRequest, res: VercelResponse) {
  const apiKey = process.env.SILICONFLOW_API_KEY;
  const imageProvider = process.env.IMAGE_PROVIDER;

  const envCheck = {
    IMAGE_PROVIDER: imageProvider || '未设置',
    SILICONFLOW_API_KEY: apiKey ? `${apiKey.substring(0, 10)}...` : '未设置',
  };

  if (!apiKey) {
    return res.status(200).json({
      success: false,
      message: '硅基流动 API Key 未配置',
      envCheck,
    });
  }

  try {
    // 动态导入 image 模块
    const { generateImage, enhancePromptForChildrenBook } = await import('./_lib/image.js');

    const prompt = 'A cute cartoon rabbit in a forest';
    const enhancedPrompt = enhancePromptForChildrenBook(prompt, 'watercolor');

    const result = await generateImage({
      prompt: enhancedPrompt,
      size: '1024x1024',
      provider: 'siliconflow',
    });

    return res.status(200).json({
      success: true,
      message: '图片生成成功！',
      envCheck,
      result: {
        imageUrl: result.imageUrl.substring(0, 100) + '...',
        provider: result.provider,
        model: result.model,
      },
    });
  } catch (error: any) {
    return res.status(200).json({
      success: false,
      message: '图片生成失败',
      envCheck,
      error: error.message,
      stack: error.stack?.substring(0, 500),
    });
  }
}

// ==================== 测试硅基流动图片生成 API ====================
export async function testSiliconflow(req: VercelRequest, res: VercelResponse) {
  const apiKey = process.env.SILICONFLOW_API_KEY;
  const imageProvider = process.env.IMAGE_PROVIDER;

  // 检查环境变量
  const envCheck = {
    IMAGE_PROVIDER: imageProvider || '未设置',
    SILICONFLOW_API_KEY: apiKey ? `${apiKey.substring(0, 10)}...` : '未设置',
  };

  if (!apiKey) {
    return res.status(200).json({
      success: false,
      message: '硅基流动 API Key 未配置',
      envCheck,
      guide: '请在 https://siliconflow.cn/ 注册并获取 API Key，然后在 Vercel 环境变量中设置 SILICONFLOW_API_KEY',
    });
  }

  // 调用硅基流动 API
  try {
    const model = 'Kwai-Kolors/Kolors';

    const response = await fetch('https://api.siliconflow.cn/v1/images/generations', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model,
        prompt: 'A cute cartoon rabbit in a forest, children book illustration style, watercolor painting, soft colors',
      }),
    });

    const responseText = await response.text();

    if (!response.ok) {
      return res.status(200).json({
        success: false,
        message: '硅基流动 API 调用失败',
        envCheck,
        debug: {
          model,
          httpStatus: response.status,
          responseBody: responseText.substring(0, 800),
        },
      });
    }

    const result = JSON.parse(responseText);
    const imageUrl = result.images?.[0]?.url || result.data?.[0]?.url;

    if (imageUrl) {
      return res.status(200).json({
        success: true,
        message: '硅基流动 API 调用成功！',
        envCheck,
        result: {
          imageUrl: imageUrl.substring(0, 100) + '...',
          model,
        },
      });
    }

    return res.status(200).json({
      success: false,
      message: '硅基流动未返回图片数据',
      envCheck,
      debug: {
        model,
        responseBody: responseText.substring(0, 500),
      },
    });
  } catch (error: any) {
    return res.status(200).json({
      success: false,
      message: '硅基流动 API 调用异常',
      envCheck,
      error: error.message,
    });
  }
}

// ==================== 测试 Google Imagen 图片生成 API ====================
export async function testImagen(req: VercelRequest, res: VercelResponse) {
  const apiKey = process.env.GOOGLE_API_KEY;
  const imageProvider = process.env.IMAGE_PROVIDER;

  // 检查环境变量
  const envCheck = {
    IMAGE_PROVIDER: imageProvider || '未设置',
    GOOGLE_API_KEY: apiKey ? `${apiKey.substring(0, 10)}...` : '未设置',
  };

  if (!apiKey) {
    return res.status(200).json({
      success: false,
      message: 'Google API Key 未配置',
      envCheck,
    });
  }

  // 调用 Google Gemini 图片生成 API
  try {
    // 尝试多个模型名称
    const models = [
      'gemini-2.0-flash-preview-image-generation',
      'imagen-3.0-generate-002',
      'imagegeneration@006',
    ];
    const model = models[0];
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: 'A cute cartoon rabbit in a forest, children book illustration style, watercolor painting, soft colors, no text',
            },
          ],
        },
      ],
      generationConfig: {
        responseModalities: ['IMAGE'],
      },
    };

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    const responseText = await response.text();

    if (!response.ok) {
      return res.status(200).json({
        success: false,
        message: 'Google Gemini API 调用失败',
        envCheck,
        debug: {
          model,
          httpStatus: response.status,
          responseBody: responseText.substring(0, 1000),
        },
      });
    }

    const result = JSON.parse(responseText);
    const candidates = result.candidates;

    // 查找图片数据
    let imageData = null;
    if (candidates && candidates[0]?.content?.parts) {
      for (const part of candidates[0].content.parts) {
        if (part.inlineData?.mimeType?.startsWith('image/')) {
          imageData = part.inlineData;
          break;
        }
      }
    }

    if (imageData) {
      return res.status(200).json({
        success: true,
        message: 'Google Gemini 图片生成成功！',
        envCheck,
        result: {
          mimeType: imageData.mimeType,
          imageUrl: `data:${imageData.mimeType};base64,${imageData.data.substring(0, 50)}...`,
          model,
        },
      });
    }

    return res.status(200).json({
      success: false,
      message: 'Google Gemini 未返回图片数据',
      envCheck,
      debug: {
        model,
        responseBody: responseText.substring(0, 800),
      },
    });
  } catch (error: any) {
    return res.status(200).json({
      success: false,
      message: 'Google Gemini API 调用异常',
      envCheck,
      error: error.message,
    });
  }
}

// ==================== 测试即梦图片生成 API（保留用于调试）====================
export async function testJimeng(req: VercelRequest, res: VercelResponse) {
  const accessKey = process.env.JIMENG_ACCESS_KEY;
  const secretKey = process.env.JIMENG_SECRET_KEY;
  const apiMode = process.env.JIMENG_API_MODE || 'async';
  const imageProvider = process.env.IMAGE_PROVIDER;

  // 检查环境变量
  const envCheck = {
    IMAGE_PROVIDER: imageProvider || '未设置',
    JIMENG_API_MODE: apiMode,
    JIMENG_ACCESS_KEY: accessKey ? `${accessKey.substring(0, 10)}...` : '未设置',
    JIMENG_SECRET_KEY: secretKey ? `长度=${secretKey.length}` : '未设置',
  };

  if (!accessKey || !secretKey) {
    return res.status(200).json({
      success: false,
      message: '即梦 API 密钥未配置',
      envCheck,
    });
  }

  // 直接调用火山引擎 API
  try {
    const nodeCrypto = await import('node:crypto');

    const service = 'cv';
    const region = 'cn-north-1';
    const action = 'CVProcess';  // 官方示例使用 CVProcess
    const version = '2022-08-31';
    const host = 'visual.volcengineapi.com';
    const method = 'POST';
    const contentType = 'application/json';

    // 请求体 - 尝试不同的 req_key
    const requestBody = {
      req_key: 'high_aes',  // 尝试更简单的 req_key
      prompt: 'A cute cartoon rabbit',
      width: 512,
      height: 512,
      return_url: true,
    };

    // 当前时间
    const now = new Date();
    const xDate = now.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
    const shortDate = xDate.substring(0, 8);

    const bodyString = JSON.stringify(requestBody);
    const bodyHash = nodeCrypto.createHash('sha256').update(bodyString).digest('hex');

    // 规范请求头 - 按字母顺序
    const signedHeaders = 'content-type;host;x-content-sha256;x-date';
    const canonicalHeaders = [
      `content-type:${contentType}`,
      `host:${host}`,
      `x-content-sha256:${bodyHash}`,
      `x-date:${xDate}`,
    ].join('\n');

    // 规范查询字符串
    const canonicalQueryString = `Action=${action}&Version=${version}`;

    // 规范请求
    const canonicalRequest = [
      method,
      '/',
      canonicalQueryString,
      canonicalHeaders + '\n',
      signedHeaders,
      bodyHash,
    ].join('\n');

    const canonicalRequestHash = nodeCrypto.createHash('sha256').update(canonicalRequest).digest('hex');
    const credentialScope = `${shortDate}/${region}/${service}/request`;

    const stringToSign = [
      'HMAC-SHA256',
      xDate,
      credentialScope,
      canonicalRequestHash,
    ].join('\n');

    // 计算签名
    const kDate = nodeCrypto.createHmac('sha256', secretKey).update(shortDate).digest();
    const kRegion = nodeCrypto.createHmac('sha256', kDate).update(region).digest();
    const kService = nodeCrypto.createHmac('sha256', kRegion).update(service).digest();
    const kSigning = nodeCrypto.createHmac('sha256', kService).update('request').digest();
    const signature = nodeCrypto.createHmac('sha256', kSigning).update(stringToSign).digest('hex');

    const authorization = `HMAC-SHA256 Credential=${accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;

    const url = `https://${host}/?${canonicalQueryString}`;

    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': contentType,
        'Host': host,
        'X-Date': xDate,
        'X-Content-Sha256': bodyHash,
        'Authorization': authorization,
      },
      body: bodyString,
    }).catch((fetchError: any) => {
      throw new Error(`Fetch 错误: ${fetchError.message} | cause: ${fetchError.cause?.message || 'unknown'}`);
    });

    const responseText = await response.text();

    return res.status(200).json({
      success: response.ok,
      message: response.ok ? '即梦 API 调用成功！' : '即梦 API 调用失败',
      envCheck,
      debug: {
        url,
        xDate,
        shortDate,
        credentialScope,
        bodyHashPrefix: bodyHash.substring(0, 20),
        canonicalRequestPreview: canonicalRequest.substring(0, 200).replace(/\n/g, '\\n'),
        stringToSignPreview: stringToSign.substring(0, 150).replace(/\n/g, '\\n'),
        signature: signature.substring(0, 20) + '...',
        httpStatus: response.status,
        responseBody: responseText.substring(0, 800),
      },
    });
  } catch (error: any) {
    return res.status(200).json({
      success: false,
      message: '即梦 API 调用异常',
      envCheck,
      error: error.message,
      stack: error.stack?.substring(0, 300),
    });
  }
}

// ==================== 测试 AI 连接 ====================
export async function testAi(req: VercelRequest, res: VercelResponse) {
  try {
    const client = getAIClient();
    const response = await client.chat.completions.create({
      model: process.env.AI_MODEL || process.env.CLAUDE_MODEL || 'glm-4-flash',
      max_tokens: 100,
      messages: [
        {
          role: 'user',
          content: '请用一句话介绍自己。',
        },
      ],
    });

    const content = response.choices[0]?.message?.content || '';

    return res.status(200).json({
      success: true,
      message: 'AI 连接成功',
      data: {
        response: content,
        model: response.model,
      },
    });
  } catch (error: any) {
    console.error('AI Test Error:', error);

    // 返回更详细的错误信息
    const errorDetails = {
      message: error?.message || 'Unknown error',
      status: error?.status,
      code: error?.code,
      type: error?.type,
      baseURL: process.env.AI_BASE_URL || process.env.ANTHROPIC_BASE_URL,
      model: process.env.AI_MODEL || process.env.CLAUDE_MODEL,
    };

    return res.status(500).json({
      success: false,
      error: {
        code: 'AI_ERROR',
        message: error instanceof Error ? error.message : 'AI 连接失败',
        details: errorDetails,
      },
    });
  }
}
